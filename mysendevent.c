//[12f23eddde] 20-01-23 a better timer
//[12f23eddde] 20-01-23 add time offset
//[12f23eddde] 20-01-23 touch-sync
//[12f23eddde] 20-01-24 add argprase
//[12f23eddde] 20-01-25 update start cond with press/release
//[12f23eddde] 20-01-25 time correction based on release time

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <stdbool.h>
#include <sys/ioctl.h>
//#include <linux/input.h> // this does not compile
#include <unistd.h>
#include <errno.h>
#include <getopt.h>
#include <sys/time.h>  // Modified

// from <linux/input.h>

typedef uint32_t        __u32;
typedef uint16_t        __u16;
typedef __signed__ int  __s32;

struct input_event {
    struct timeval time;
    __u16 type;
    __u16 code;
    __u32 value;
};

#define MICROSEC 1000000
#define TRUNC(x) ( x > 0 ? x : 0 ) // avoid uint overflow

// begin <linux/input.h>

#define EVIOCGVERSION		_IOR('E', 0x01, int)			/* get driver version */
#define EVIOCGID		_IOR('E', 0x02, struct input_id)	/* get device ID */
#define EVIOCGKEYCODE		_IOR('E', 0x04, int[2])			/* get keycode */
#define EVIOCSKEYCODE		_IOW('E', 0x04, int[2])			/* set keycode */

#define EVIOCGNAME(len)		_IOC(_IOC_READ, 'E', 0x06, len)		/* get device name */
#define EVIOCGPHYS(len)		_IOC(_IOC_READ, 'E', 0x07, len)		/* get physical location */
#define EVIOCGUNIQ(len)		_IOC(_IOC_READ, 'E', 0x08, len)		/* get unique identifier */

#define EVIOCGKEY(len)		_IOC(_IOC_READ, 'E', 0x18, len)		/* get global keystate */
#define EVIOCGLED(len)		_IOC(_IOC_READ, 'E', 0x19, len)		/* get all LEDs */
#define EVIOCGSND(len)		_IOC(_IOC_READ, 'E', 0x1a, len)		/* get all sounds status */
#define EVIOCGSW(len)		_IOC(_IOC_READ, 'E', 0x1b, len)		/* get all switch states */

#define EVIOCGBIT(ev,len)	_IOC(_IOC_READ, 'E', 0x20 + ev, len)	/* get event bits */
#define EVIOCGABS(abs)		_IOR('E', 0x40 + abs, struct input_absinfo)		/* get abs value/limits */
#define EVIOCSABS(abs)		_IOW('E', 0xc0 + abs, struct input_absinfo)		/* set abs value/limits */

#define EVIOCSFF		_IOC(_IOC_WRITE, 'E', 0x80, sizeof(struct ff_effect))	/* send a force effect to a force feedback device */
#define EVIOCRMFF		_IOW('E', 0x81, int)			/* Erase a force effect */
#define EVIOCGEFFECTS		_IOR('E', 0x84, int)			/* Report number of effects playable at the same time */

#define EVIOCGRAB		_IOW('E', 0x90, int)			/* Grab/Release device */

// end <linux/input.h>

long long get_usec(struct timeval *tv_ptr){
    gettimeofday(tv_ptr, NULL);
    return 1000000 * tv_ptr->tv_sec + tv_ptr->tv_usec;
}

void remove_specific_chars(char* str, char c1, char c2) {
    char *pr = str, *pw = str;
    while (*pr) {
        *pw = *pr++;
        pw += (*pw != c1 && *pw != c2);
    }
    *pw = '\0';
}

int main(int argc, char *argv[])
{
    int fd = -1;
    int ret;
    int version;

    // Modified
    bool debug = false;
    bool wait_for_input = false;
    struct input_event event;
    struct timeval tv;
    long offset = 0;
    float release_timeout = 0.2;
    FILE *fd_in = NULL;

    // parsing arguments
    printf("[mysendevent]");
    int c;
    while ((c = getopt (argc, argv, "t:e:o:r:hwv")) != -1) {
        switch (c) {
            case 't':  // trace
                fd_in = fopen(optarg, "r");
                printf(" trace=%s",optarg);
                break;
            case 'e':  // device_event
                fd = open(optarg, O_RDWR);
                printf(" dev=%s",optarg);
                break;
            case 'o':  // offset
                offset = strtol(optarg, NULL, 10);
                printf(" offset=%ld(ms)",offset);
                break;
            case 'r':  // release_timeout
                release_timeout = strtof(optarg, NULL);
                printf(" release_timeout=%.2f(ms)",release_timeout);
                break;
            case 'w':  // wait_for_input
                wait_for_input = true;
                printf(" wait_for_input");
                break;
            case 'v':
                debug = true;
                printf(" debug");
                break;
            case 'h':
            case '?':
            default:
                printf("Usage: -t <trace> -e <device_event> -o <offset> -r <release_timeout> -w -v\n");
                printf("       -t trace generated by getevent -t\n");
                printf("       -e event in linux IO i.e. /dev/input/event1\n");
                printf("       -o offset to sendevent actions (ms)\n");
                printf("       -r threshold of separating different actions\n");
                printf("       -w wait for input before mysendevent\n");
                printf("       -v show debug outputs\n");
                return 0;
        }
    }
    printf("\n");

    // handle exceptions
    if(fd < 0) {
        fprintf(stderr, "could not open device event, %s\n", strerror(errno));
        return 1;
    }
    if (ioctl(fd, EVIOCGVERSION, &version)) {
        fprintf(stderr, "could not get driver version, %s\n", strerror(errno));
        return 1;
    }
    if (fd_in == NULL) {
        fprintf(stderr, "could not open trace file, %s\n", strerror(errno));
        return 1;
    }

    char line[128];
    char type[32];
    char code[32];
    char value[32];

    // Modified
    unsigned int sleep_time;
    double timestamp_init = -1.0;
    double timestamp_prev_release = -1.0;
    double timestamp_now;
    long long usec_init = -1;
    int press_cnt = 0;
    int release_cnt = 0;
    bool is_press = false;
    bool is_release = false;
    bool is_first_act = true;
    long long corr_offset_sum = 0;

    if(wait_for_input){
        printf("[mysendevent] Waiting for touch event\n");
        // received input from touchscreen -> continue
        read(fd, &event, sizeof(event));
        printf("[mysendevent] Got touch event, waiting for 1st release\n");
    }else{
        // disable some features
        is_first_act = false;
    }

    while (fgets(line, sizeof(line), fd_in) != NULL) {
        // remove the characters [ and ] surrounding the timestamp
        remove_specific_chars(line, '[', ']');
        sscanf(line, "%lf %s %s %s", &timestamp_now, type, code, value);

        // write the event to the appropriate input device
        event.type = (int) strtol(type, NULL, 16);
        event.code = (int) strtol(code, NULL, 16);
        event.value = (uint32_t) strtoll(value, NULL, 16);

        // press/release code val: 0x0039
        // release event val: 0xffffffff
        // might be device-dependent?
        if(event.code == (int) 0x0039) {
            if (event.value == (uint32_t) 0xffffffff) {
                is_release = true;
                release_cnt++;
            }
            else{
                is_press = true;
                press_cnt++;
            }
        }

        long long usec_now = get_usec(&tv);
        long long sleep_time_fixed = (long long)((timestamp_now - timestamp_init) * MICROSEC) - (usec_now - usec_init);
        sleep_time = TRUNC(sleep_time_fixed);  // more accurate

        // set init val
        if(usec_init == -1){
            usec_init = usec_now;
        }
        if(timestamp_init == -1.0){
            timestamp_init = timestamp_now;
        }

        if(sleep_time!=0){
            //if(debug) printf("[%4d] sleep_time = (%lf-%lf)*1000000 - (%lld - %lld) = %u (us)\n",
                             //release_cnt,timestamp_now,timestamp_init,usec_now,usec_init,sleep_time);
            usleep(sleep_time); // sleep (us)

            if(is_press){
                if(debug) printf("[%4d] %lf: press_cnt=%d, release_cnt=%d\n",(press_cnt+release_cnt+1)/2,timestamp_now,press_cnt,release_cnt);
                is_press = false;
            }

            if(is_release){
                if(debug) printf("[%4d] %lf: release_cnt=%d, press_cnt=%d\n",(press_cnt+release_cnt+1)/2,timestamp_now,press_cnt,release_cnt);
                // set timestamp on 1st release
                timestamp_prev_release = timestamp_now;
                if(!is_first_act) is_release = false;  //reset later
            }

            // set is_first_act = false when:
            // flushing IO
            // not first release
            // > release_timeout from last release
            // press_cnt == release_cnt
            if(is_first_act && release_cnt > 0 && timestamp_prev_release!=-1.0
               && timestamp_now - timestamp_prev_release > release_timeout && press_cnt == release_cnt){
                printf("[mysendevent] Sendevent begin, press ENTER to stop\n");
                is_first_act = false;
                // time correction
                long long offset_final = 1000*offset - corr_offset_sum/release_cnt;
                if(debug) printf("[%4d] %lf: offset_final=%lld(ns)\n",(press_cnt+release_cnt+1)/2,timestamp_now,offset_final);
                usec_init += offset_final;
            }
        }

        if(!is_first_act){
            ret = write(fd, &event, sizeof(event));
            if(ret < sizeof(event)) {
                fprintf(stderr, "write event failed, %s\n", strerror(errno));
                return -1;
            }
        }else if(is_release){  // time correction: only press/release time is reliable
            read(fd, &event, sizeof(event));
            usec_now = get_usec(&tv);
            long long corr_offset = (long long)((timestamp_now - timestamp_init) * MICROSEC) - (usec_now - usec_init);
            if(debug) printf("[%4d] %lf: corr_offset=%lld(ns)\n",(press_cnt+release_cnt+1)/2,timestamp_now,corr_offset);
            corr_offset_sum += corr_offset;
            is_release = false;
        }

        // Clear temporary buffers
        memset(line, 0, sizeof(line));
        memset(type, 0, sizeof(type));
        memset(code, 0, sizeof(code));
        memset(value, 0, sizeof(value));
    }

    printf("[mysendevent] Sendevent stopped normally\n");

    fclose(fd_in);
    close(fd);

    return 0;
}